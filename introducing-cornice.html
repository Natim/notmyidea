<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <link rel="stylesheet" href="./theme/css/main.css" type="text/css" media="screen" charset="utf-8">
        <link href="./feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Alexis' log ATOM Feed" />
    <title>Alexis Métaireau</title>
</head>
<body>
    <div id="top">
        <p class="author"><a href=".">Alexis Métaireau</a>'s thougths</p>
        <ul class="links"></ul>
    </div>
    <div class="content clear">
    <h1>Introducing Cornice</h1>
    <p class="date">Published on Wed 07 December 2011</p>
    <p>Wow, already my third working day at Mozilla. Since Monday, I've been working with
<a class="reference external" href="http://ziade.org">Tarek Ziadé</a>, on a pyramid REST-ish toolkit named <a class="reference external" href="https://github.com/mozilla-services/cornice">Cornice</a>.</p>
<p>Its goal is to take care for you of what you're usually missing so you can
focus on what's important. Cornice provides you facilities
for validation of any kind.</p>
<p>The goal is to simplify your work, but we don't want to reinvent the wheel, so
it is easily pluggable with validations frameworks, such as <a class="reference external" href="http://docs.pylonsproject.org/projects/colander/en/latest/">Colander</a>.</p>
<div class="section" id="handling-errors-and-validation">
<h2>Handling errors and validation</h2>
<p>Here is how it works:</p>
<div class="highlight"><pre><span class="n">service</span> <span class="o">=</span> <span class="n">Service</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;service&quot;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s">&quot;/service&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_awesome</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;awesome&#39;</span> <span class="ow">in</span> <span class="n">request</span><span class="o">.</span><span class="n">GET</span><span class="p">:</span>
        <span class="n">request</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;query&#39;</span><span class="p">,</span> <span class="s">&#39;awesome&#39;</span><span class="p">,</span>
                            <span class="s">&#39;the awesome parameter is required&#39;</span><span class="p">)</span>


<span class="nd">@service.get</span><span class="p">(</span><span class="n">validator</span><span class="o">=</span><span class="n">is_awesome</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get1</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">&quot;test&quot;</span><span class="p">:</span> <span class="s">&quot;yay!&quot;</span><span class="p">}</span>
</pre></div>
<p>All the errors collected during the validation process, or after, are collected
before returning the request. If any, a error 400 is fired up, with the list of
problems encountered returned as a nice json list response (we plan to support
multiple formats in the future)</p>
<p>As you might have seen, <cite>request.errors.add</cite> takes three parameters: <strong>location</strong>,
<strong>name</strong> and <strong>description</strong>.</p>
<p><strong>location</strong> is where the error is located in the request. It can either be &quot;body&quot;,
&quot;query&quot;, &quot;headers&quot; or &quot;path&quot;. <strong>name</strong> is the name of the variable causing
problem, if any, and <strong>description</strong> contains a more detailed message.</p>
<p>Let's run this simple service and send some queries to it:</p>
<pre class="literal-block">
$ curl -v http://127.0.0.1:5000/service
&gt; GET /service HTTP/1.1
&gt; Host: 127.0.0.1:5000
&gt; Accept: */*
&gt;
* HTTP 1.0, assume close after body
&lt; HTTP/1.0 400 Bad Request
&lt; Content-Type: application/json; charset=UTF-8
[{&quot;location&quot;: &quot;query&quot;, &quot;name&quot;: &quot;awesome&quot;, &quot;description&quot;: &quot;You lack awesomeness!&quot;}
</pre>
<p>I've removed the extra clutter from the curl's output, but you got the general idea.</p>
<p>The content returned is in JSON, and I know exactly what I have to do: add an
&quot;awesome&quot; parameter in my query. Let's do it again:</p>
<pre class="literal-block">
$ curl http://127.0.0.1:5000/service?awesome=yeah
{&quot;test&quot;: &quot;yay!&quot;}
</pre>
<p>Validators can also convert parts of the request and store the converted value
in <cite>request.validated</cite>. It is a standard dict automatically attached to the
requests.</p>
<p>For instance, in our validator, we can chose to validate the parameter passed
and use it in the body of the webservice:</p>
<div class="highlight"><pre><span class="n">service</span> <span class="o">=</span> <span class="n">Service</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;service&quot;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s">&quot;/service&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_awesome</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;awesome&#39;</span> <span class="ow">in</span> <span class="n">request</span><span class="o">.</span><span class="n">GET</span><span class="p">:</span>
        <span class="n">request</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;query&#39;</span><span class="p">,</span> <span class="s">&#39;awesome&#39;</span><span class="p">,</span>
                            <span class="s">&#39;the awesome parameter is required&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">request</span><span class="o">.</span><span class="n">validated</span><span class="p">[</span><span class="s">&#39;awesome&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;awesome &#39;</span> <span class="o">+</span> <span class="n">request</span><span class="o">.</span><span class="n">GET</span><span class="p">[</span><span class="s">&#39;awesome&#39;</span><span class="p">]</span>


<span class="nd">@service.get</span><span class="p">(</span><span class="n">validator</span><span class="o">=</span><span class="n">is_awesome</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get1</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">&quot;test&quot;</span><span class="p">:</span> <span class="n">request</span><span class="o">.</span><span class="n">validated</span><span class="p">[</span><span class="s">&#39;awesome&#39;</span><span class="p">]}</span>
</pre></div>
<p>The output would look like this:</p>
<pre class="literal-block">
curl http://127.0.0.1:5000/service?awesome=yeah
{&quot;test&quot;: &quot;awesome yeah&quot;}
</pre>
</div>
<div class="section" id="dealing-with-accept-headers">
<h2>Dealing with &quot;Accept&quot; headers</h2>
<p>The HTTP spec defines a <strong>Accept</strong> header the client can send so the response
is encoded the right way. A resource, available at an URL, can be available in
different formats. This is especially true for web services.</p>
<p>Cornice can help you dealing with this. The services you define can tell which
<cite>Content-Type</cite> values they can deal with and this will be checked against the
<strong>Accept</strong> headers sent by the client.</p>
<p>Let's refine a bit our previous example, by specifying which content-types are
supported, using the <cite>accept</cite> parameter:</p>
<div class="highlight"><pre><span class="nd">@service.get</span><span class="p">(</span><span class="n">validator</span><span class="o">=</span><span class="n">is_awesome</span><span class="p">,</span> <span class="n">accept</span><span class="o">=</span><span class="p">(</span><span class="s">&quot;application/json&quot;</span><span class="p">,</span> <span class="s">&quot;text/json&quot;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">get1</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">&quot;test&quot;</span><span class="p">:</span> <span class="s">&quot;yay!&quot;</span><span class="p">}</span>
</pre></div>
<p>Now, if you specifically ask for XML, Cornice will throw a 406 with the list of
accepted <cite>Content-Type</cite> values:</p>
<pre class="literal-block">
$ curl -vH &quot;Accept: application/xml&quot; http://127.0.0.1:5000/service
&gt; GET /service HTTP/1.1
&gt; Host: 127.0.0.1:5000
&gt; Accept: application/xml
&gt;
&lt; HTTP/1.0 406 Not Acceptable
&lt; Content-Type: application/json; charset=UTF-8
&lt; Content-Length: 33
&lt;
[&quot;application/json&quot;, &quot;text/json&quot;]
</pre>
</div>
<div class="section" id="building-your-documentation-automatically">
<h2>Building your documentation automatically</h2>
<p>writing documentation for web services can be painful, especially when your
services evolve. Cornice provides a sphinx directive to automatically document
your API in your docs.</p>
<div class="highlight"><pre><span class="p">..</span> <span class="ow">services</span><span class="p">::</span>
   <span class="nc">:package:</span> <span class="nf">coolapp</span>
   <span class="nc">:service:</span> <span class="nf">quote</span>
</pre></div>
<p>Here is an example of what a generated page looks like: <a class="reference external" href="http://packages.python.org/cornice/exampledoc.html">http://packages.python.org/cornice/exampledoc.html</a></p>
</div>
<div class="section" id="yay-how-can-i-get-it">
<h2>Yay! How can I get it?</h2>
<p>We just cut a 0.4 release, so it's available at <a class="reference external" href="http://pypi.python.org/pypi/cornice">http://pypi.python.org/pypi/cornice</a>
You can install it easily using <cite>pip</cite>, for instance:</p>
<pre class="literal-block">
$ pip install cornice
</pre>
<p>You can also have a look at the documentation at
<a class="reference external" href="http://packages.python.org/cornice/">http://packages.python.org/cornice/</a></p>
</div>
<div class="section" id="what-s-next">
<h2>What's next?</h2>
<p>We try to make our best to find how Cornice can help you build better
web services. Cool features we want for the future include the automatic
publication of a static definition of the services, so it can be used by clients
to discover services in a nice way.</p>
<p>Of course, we are open to all your ideas and patches! If you feel haskish and
want to see the sources, <a class="reference external" href="https://github.com/mozilla-services/cornice">go grab them on github</a>
, commit and send us a pull request!</p>
</div>


    
    <div class="comments">
    <h2>Comments</h2>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
           var disqus_identifier = "introducing-cornice.html";
           (function() {
           var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
           dsq.src = 'http://blog-notmyidea.disqus.com/embed.js';
           (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
    </div>
    
</div>
</body>
</html>